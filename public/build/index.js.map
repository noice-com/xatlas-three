{"version":3,"file":"index.js","mappings":"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","sources":["webpack://xatlas-three/webpack/bootstrap","webpack://xatlas-three/webpack/runtime/define property getters","webpack://xatlas-three/webpack/runtime/hasOwnProperty shorthand","webpack://xatlas-three/./src/UVUnwrapper.ts","webpack://xatlas-three/./src/baseXAtlas.ts","webpack://xatlas-three/./node_modules/comlink/dist/esm/comlink.mjs","webpack://xatlas-three/./src/XAtlasWebWorker.ts","webpack://xatlas-three/./src/unwrapperWorker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class BaseUVUnwrapper {\n    /**\n     *\n     * @param THREE - for reference to BufferAttribute\n     * @param packOptions - options for packing\n     * @param chartOptions - options for unwrapping\n     * @param useNormals - If true, will use the normals to calculate the uv\n     * @param timeUnwrap - Logs the time taken to unwrap geometries\n     * @param logProgress - Logs the unwrapping progress\n     */\n    constructor(THREE, packOptions = {\n        resolution: 2048,\n    }, chartOptions = {}, useNormals = false, timeUnwrap = false, logProgress = false) {\n        this.THREE = THREE;\n        this.packOptions = packOptions;\n        this.chartOptions = chartOptions;\n        this.useNormals = useNormals;\n        this.timeUnwrap = timeUnwrap;\n        this.logProgress = logProgress;\n        this._libraryLoaded = false;\n        this._isUnwrapping = false;\n        this.xAtlas = this._createXAtlas();\n    }\n    loadLibrary(onProgress, wasmFilePath, workerFilePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._libraryLoaded)\n                return;\n            yield new Promise((resolve, reject) => {\n                try {\n                    this.xAtlas.init(() => {\n                        resolve();\n                    }, onProgress, wasmFilePath, workerFilePath);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n            while (!(this.xAtlas.api ? yield this.xAtlas.api.loaded : false)) {\n                yield new Promise(r => setTimeout(r, 100)); // wait for load just in case\n            }\n            this._libraryLoaded = true;\n        });\n    }\n    /**\n     * Pack multiple geometry into a single atlas\n     * @param THREE\n     * @param nodeList - list of geometries to unwrap\n     * @param outputUv - Attribute to write the output uv to\n     * @param inputUv - Attribute to write the input uv to (if any)\n     */\n    packAtlas(nodeList, outputUv = 'uv2', inputUv = 'uv') {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._libraryLoaded) {\n                console.warn('xatlas-three: library not loaded');\n                return [];\n            }\n            if (!nodeList)\n                return [];\n            if (nodeList.length < 1)\n                return [];\n            const useUvs = this.chartOptions.useInputMeshUvs;\n            while (this._isUnwrapping) {\n                console.log(\"xatlas-three: unwrapping another mesh, waiting 100 ms\");\n                yield new Promise(r => setTimeout(r, 100));\n            }\n            // if(!(xAtlas.loaded)) { // when not using worker. todo\n            // xAtlas.addOnLoad(proxy(()=>xAtlasUnWrapLiteGLMeshes(nodeList, onFinish, chartOptions, packOptions, useNormals, useUvs, resultAttribute, originalAttribute)));\n            // return;\n            // }\n            this._isUnwrapping = true;\n            yield this.xAtlas.api.setProgressLogging(this.logProgress);\n            yield this.xAtlas.api.createAtlas();\n            let meshAdded = [];\n            let tag = \"\"; // for time logging\n            for (let mesh of nodeList) {\n                let { uuid, index, attributes } = mesh;\n                const scaled = mesh.userData.worldScale || 1; // can be [number, number, number] or number\n                // if (unwrap === false) continue;\n                meshAdded.push(uuid);\n                if (!index || !attributes.position || attributes.position.itemSize !== 3) {\n                    console.warn(\"xatlas-three: Geometry not supported: \", mesh);\n                    continue;\n                }\n                tag = \"Mesh\" + meshAdded.length + \" added to atlas: \" + uuid;\n                // console.log(typeof index.array)\n                if (this.timeUnwrap)\n                    console.time(tag);\n                yield this.xAtlas.api.addMesh(index.array, attributes.position.array, attributes.normal ? attributes.normal.array : undefined, attributes.uv ? attributes.uv.array : undefined, uuid, this.useNormals, useUvs, scaled);\n                if (this.timeUnwrap)\n                    console.timeEnd(tag);\n            }\n            tag = \"Generated atlas with \" + meshAdded.length + \" meshes\";\n            if (this.timeUnwrap)\n                console.time(tag);\n            let meshes = yield this.xAtlas.api.generateAtlas(this.chartOptions, this.packOptions, true);\n            if (this.timeUnwrap)\n                console.timeEnd(tag);\n            let ret = [];\n            for (let m of meshes) {\n                /**\n                 * @type {Mesh}\n                 */\n                let mesh = nodeList.find(n => n.uuid === m.mesh);\n                if (!mesh) {\n                    console.error(\"xatlas-three: Mesh not found: \", m.mesh);\n                    continue;\n                }\n                // if(mesh.getAttribute(\"position\"))\n                //     mesh.deleteAttribute(\"position\");\n                // if(mesh.getAttribute(\"normal\") && m.vertex.normal)\n                //     mesh.deleteAttribute(\"normal\");\n                // if(mesh.getAttribute(\"uv\") && m.vertex.uv)\n                //     mesh.deleteAttribute(\"uv\");\n                // if(mesh.getAttribute(\"uv2\"))\n                //     mesh.deleteAttribute(\"uv2\");\n                // if(mesh.getIndex())\n                //     mesh.setIndex(null);\n                if (m.vertex.vertices)\n                    mesh.setAttribute('position', new this.THREE.BufferAttribute(m.vertex.vertices, 3, false));\n                if (m.vertex.normals)\n                    mesh.setAttribute('normal', new this.THREE.BufferAttribute(m.vertex.normals, 3, true));\n                if (m.vertex.coords1)\n                    mesh.setAttribute(outputUv, new this.THREE.BufferAttribute(m.vertex.coords1, 2, false));\n                if (m.vertex.coords && outputUv !== inputUv)\n                    mesh.setAttribute(inputUv, new this.THREE.BufferAttribute(m.vertex.coords, 2, false));\n                if (m.index)\n                    mesh.setIndex(new this.THREE.BufferAttribute(m.index, 1, false));\n                ret.push({ geometry: mesh, oldIndexes: m.oldIndexes });\n            }\n            yield this.xAtlas.api.destroyAtlas();\n            this._isUnwrapping = false;\n            return ret;\n        });\n    }\n    /**\n     * Unwraps a geometry to generate uv\n     * @param geometry\n     * @param outputUv\n     * @param inputUv\n     */\n    unwrapGeometry(geometry, outputUv = 'uv', inputUv = 'uv2') {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.packAtlas([geometry], outputUv, inputUv);\n        });\n    }\n}\n","export class BaseXAtlas {\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseXAtlas } from \"./baseXAtlas\";\nimport { proxy, wrap } from \"comlink\";\nexport class XAtlasWebWorker extends BaseXAtlas {\n    init(onLoad, onProgress, wasmFilePath, workerFilePath) {\n        if (this.api)\n            return;\n        if (!workerFilePath)\n            throw new Error(\"workerFilePath is required\");\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const workerCode = yield fetch(workerFilePath).then(res => res.blob());\n            const workerUrl = URL.createObjectURL(workerCode);\n            const t = new Worker(workerUrl, { type: 'module', });\n            // @ts-ignore\n            this.api = yield (new (wrap(t))(proxy(() => {\n                onLoad();\n                URL.revokeObjectURL(workerUrl);\n            }), proxy((path, dir) => {\n                return (path === \"xatlas_web.wasm\" ? wasmFilePath : path + dir);\n            }), proxy(onProgress)));\n        }))();\n    }\n}\n","import { BaseUVUnwrapper } from \"./UVUnwrapper\";\nimport { XAtlasWebWorker } from \"./XAtlasWebWorker\";\nexport class UVUnwrapper extends BaseUVUnwrapper {\n    _createXAtlas() {\n        return new XAtlasWebWorker();\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","BaseUVUnwrapper","constructor","THREE","packOptions","resolution","chartOptions","useNormals","timeUnwrap","logProgress","this","_libraryLoaded","_isUnwrapping","xAtlas","_createXAtlas","loadLibrary","onProgress","wasmFilePath","workerFilePath","init","api","loaded","r","setTimeout","packAtlas","nodeList","outputUv","inputUv","console","warn","length","useUvs","useInputMeshUvs","log","setProgressLogging","createAtlas","meshAdded","tag","mesh","uuid","index","attributes","scaled","userData","worldScale","push","position","itemSize","time","addMesh","array","normal","undefined","uv","timeEnd","meshes","generateAtlas","ret","m","find","n","vertex","vertices","setAttribute","BufferAttribute","normals","coords1","coords","setIndex","geometry","oldIndexes","error","destroyAtlas","unwrapGeometry","BaseXAtlas","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","serialized","Error","isError","message","name","stack","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","rawValue","proxy","transfers","transferCache","set","transfer","catch","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","concat","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","XAtlasWebWorker","onLoad","workerCode","fetch","res","blob","workerUrl","URL","createObjectURL","t","Worker","revokeObjectURL","dir","UVUnwrapper"],"sourceRoot":""}